27-28.11.2023 Reading the Media Foundation documentation, looking for info on how to use the H.264 codec. Tried to compile open H.264 from Cisco, couldn't install all the required tools or understand which tools I need. mingw website was down and I can't find where I have mingw installed. Designed the interface and featureset of the app.
29.11.2023 Fixed a crash in the hitbox overlay. Redesigned the hitbox data to better fit into being sent over to the external program. Laid some foundation for having multiple offscreen surfaces. Laid png button interface foundation. Fucked with Win32 tooltips. Solved a problem with 4-byte alignment of stride for DIBs that store decoded PNG data for button images.
30.11.2023 Managed to compile libpng for 64 bit. Got tooltips working with unicode. Managed to inject the DLL into the process from the 64-bit app. Made vnsprintf work with unicode to output errors in msgboxes. Made process watcher that waits for guilty gear to exit and made interactions with the watcher thread-safe. Started designing data serialization format that will be used both in the file mapping and the file format. Added finishing touches to the multiple offscreen surfaces frame depositing code (no reading code yet).
01.12.2023 Started working on thread loops in the DLL and fleshing out the file mapping format further. Replaced pointers in the mapping with offsets. Started making uninjection mechanism but got stuck due to making a mistake somewhere. Added inputs, replay data sigs and offsets and added them to the draw data, described them in the file mapping format.
02.12.2023 Got uninjection working.
03.12.2023 Got stuck on the graphics thread freezing due to waiting on a logic buffer slot freeing up. This happens after about 30 seconds of running. Was pretty much just trying to find where the threads are crashing and putting log messages in. Had a lot of CComPtr asserts firing off and null pointer usages and mismatched vector iterators, that I was still getting on the next day.
04.12.2023 Debugged the frame marshalling fully, found all the corrupt memory and out of bounds memory writes, found logic thread freezes and forgotten draw data clears. We're now getting the frames in a stable way. Fixed GetDC memory leak. Figured out a way to draw textures using DrawPrimitiveUP and draw a render target only onto a portion of the screen, as well as create a device with a lockable render target from the start for quick render target updates. Made stop button and recording stoppage. Made all buttons with alpha and changed their loading so now it loads with alpha.
05.12.2023 Participated in a tourney and put out a video of inputs display working in online.
06.12.2023 Made inputs display as close to how GG itself displays them as possible. Fixed an issue with boxes flickering due to skipped frames. Fixed an issue with recording continuing even on victory screen in versus. Tested vertex buffers. Started rewriting Graphics class to use vertex buffers.
07.12.2023 17:40 Fully completed the transition to using vertex buffers instead of DrawPrimitiveUP.
07.12.2023 19:48 Fully completed the transition to using vertex buffers instead of DrawPrimitiveUP. Had to fix a rare glitch that happens due to thick line vertex padding. That took two hours because I really didn't want to turn the logging back on.
08.12.2023 Started writing the codec initialization, got stuck on YUV conversion. Was thinking about using Direct3D for YUV conversion or for displaying the video frame. Was thinking about cross-platformness for Linux and whether I'm going to be able to encode the video in such a way that the Linux decoder will be able to read it.
09.12.2023 Made the YUV conversion and got the ProcessInput - ProcessOutput loop going without errors (10:43 landmark). Studying the attributes of output samples. Going to make a decoder as well and shove encoder into decoder and display the output. 21:35 managed to connect encoder to decoder to direct 3d YUY2 surface to X8R8G8B8 render target and got a green rectangle. This means something but I don't really know what.
10.12.2023 Turns out I was copying the Direct3D locked rectangle into itself, fixed that, and now I get a smeared mess with pixel stretching on the bottom. The colors at least seem to be correct. Now I need to figure out at which point the stretching happens. The stretching was happening because I was copying the source image into the encoder wrong. Now it only produces one frame and never updates it or anything. Turns out the encoder was actually reusing the output buffer that I gave it to write result into for it's own internal use. I made a ring buffer of 1000 output buffers, but as soon as I come back to 0, 1, 2 (doesn't matter) the decoder generates an E_FAIL error. So I made the buffers constantly allocate memory and release them myself after I've read data from them. Watched memory usage, doesn't seem to rise up constantly, so don't know what was all that about.
20:12 Finally made the decoder not fail when it decodes frames. It now displays frames in a very weird way and reorders them. Am I supposed to order the frames myself?? How do I do that in real time?
11.12.2023 WorseThanYou gave a hint about keyframes and the fact that frames don't have to follow in the same order they're encoded in. So I decided to end the stream when it's time to insert a new keyframe, drain it completely and then feed that to the decoder, end its stream, drain it, read from it completely, then sort the frames by presentation time (sample time) and show in that order. It was difficult to get this exact sequence working until I started logging absolutely everything and I had to lower the number of frames per keyframe to achieve zero skipped frames. When I restart the stream on the encoder I also have to tell it to force keyframe, because apparently restarting your stream is not grounds enough to start with a new keyframe. Now we have zero skips and the codec is working perfect and we have an absolute clear understanding of how it's supposed be used. 14:45 landmark, absolute milestone. Thinking now of how to apply this for our goals, how the interactions with the video display during recording should be laid out exactly.
12.12.2023 The decoder is leaking memory. It holds all samples it ever writes output into. I must investigate. Turned out it was not leaking memory and was simply appending data to the end of buffers that I gave it, hence why it was failing on reused samples. Calling infiniteMediaBuffer->SetCurrentLength(0); solved the problem. Now everything is running on ring buffers of samples. And officially, for the first time, I have all of the needed tech, I have explored all of the areas I could possibly need, to program the WINDOWS version of the mod (without worrying about Linux for now) from start to finish, without stopping to research anything. We have: threads, events, encoder, decoder, how they behave, the presentation (YUV to RGB conversion on Direct3D), the timer, the mutexes, the file mapping, the enough amount of guilty gear reversal, the inputs, how to draw them, how to draw them the way guilty gear draws them, vertex buffers (if we need them), how to make a button, how to make a window, the paint events, the tooltips, the menubar of the window.
18.12.2023 During the past 5 days I've been lazily writing all the required workqueue, memory allocation, references and worker thread classes needed to get the recording and playback basic functionalities (the recording one makes no sense and is impossible to test without the playback one). It's finally over. The basic threads now can record a video with some logic data (that I discard for now) and then I can play back that video. The framerate is too low for now but it's usable. We're going to move on with adding some kind of controls to the video and make sure they're responsive. What I really want is seeking the video (for that I'll need the index, which I think I'm not even writing yet) and playing back the video as it's being written - which is the whole point of me implementing my own video player in the first place.
19.12.2023 Added ensured EOF sending when you hit stop recording with thread synchronization, file header, started writing index, hitbox data and replay inputs, read the header, index, hitbox data, replay inputs, added missing fields to header. Shit broke, I thought it was due to new EOF functionality but it was actually the bounds checking for data coming in from the file mapping and file. I thought maybe let it read outside the file mapping bounds but just not let it write outside the destination buffer's size. I think some time before this I also made it so you can now open a file, play it, then open another file and play that without having to restart the app, and that required some massive pipe-cleaning, sending "you need to stop" signal into all the worker queues and waiting for their replies one-by-one. I think I did this synchronization today. This is all going very slowly because there's an ungodly amount of worker threads and work queues that need to be ordered and not turned into mess. So it's all very fickle, error-prone, falls into deadlocks on every opportunity and I think I forgot the situation when Guilty Gear crashes and doesn't send the rest of EOF - we need to stop the entire recording pipeline when GG exits, possibly abruptly. It's like application exit for it, but not application exit exactly, and threads must not outright quit - they must stay. We can keep the file (what was recorded into it so far at the moment of crash) I guess.
20.12.2023 Recorded a video and fixed May's dolphin hurtbox rotation.
21.12.2023 Finished making the seekbar. Works properly. Fixed a giant memory leak. Now thinking on updating the pause button to play button when video finishes. It's a problem because I need to synchronize the mouse click way of changing the button and isPlaying field with the automatic way of the button+field changing on their own. Nvm, a new problem appeared. I made the playback wrong. I based it only on the fact it would be playing images, while now I'm sort of changing the scope of the project from displaying boxes + displaying inputs+boxes in-game etc to just doing a basic task of capturing and displaying and letting user copy the inputs with video aid. Considering the file size of the 60 FPS video I want the frames to be fewer and smaller, if the goal is to just copy the inputs. So now I'm looking at ways to actually display and scroll, automatically scroll, select, etc the inputs. Should they be part of the video? If yes I'd have to make my own scrollbars which I would fucking hate.
22.12.2023 Was reading scrollbar documentation, prepared notes. Created and positioned scrollbars. Made layout class. Started working on displaying inputs, but parsing them into draw commands first.
23.12.2023 Made inputs display and sync to the video/scrubbing. Also made the playback be based on logic data, instead of frames. Fixed file writing so that a logic always starts with a sample, so that when scrubbing we get the current frame instead of the next frame. Fixed the seekbar height so it's actually always 5 px now.
30.12.2023 Making finishing touches to the mod. Started testing on laptop yesterday. The mod instantly froze on there as soon as starting recording. The issue was not reproducable when the logging is turned on because logging has a sleep call in it. Without logging the issue was reproducable but I was blind and had to guess. I guessed right that the problem was calling IDirect3DSurface9->UnlockRect in a thread other than the dedicated graphics thread. The file mapping initially was unlocking rects on its own in order to freed up resources sooner but turns out that was a mistake. Moving the call to the graphics thread solved the issue and mod runs fine now even on laptop. Which is bonkers.